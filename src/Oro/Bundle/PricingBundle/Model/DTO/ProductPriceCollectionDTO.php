<?php

declare(strict_types=1);

namespace Oro\Bundle\PricingBundle\Model\DTO;

use Oro\Bundle\PricingBundle\Model\ProductPriceInterface;

/**
 * Collection of a {@see ProductPriceInterface} objects.
 */
class ProductPriceCollectionDTO extends \ArrayObject
{
    /**
     * @var array|null Array with arbitrary structure generated by $productPricesMapInitCallback from the list
     *  of ProductPriceInterface objects.
     *  Product prices map created by default init callback:
     *      [
     *          42 => [ // Product id
     *              'item' => [ // ProductUnit code
     *                  'USD' => [ // Currency
     *                      ProductPriceInterface,
     *                      // ...
     *                  ],
     *                  // ...
     *              ],
     *              // ...
     *          ],
     *          // ...
     *      ]
     */
    protected ?array $productPricesMap = null;

    protected \Closure $productPricesMapInitCallback;

    public function __construct(object|array $array = [], int $flags = 0, string $iteratorClass = "ArrayIterator")
    {
        parent::__construct($array, $flags, $iteratorClass);

        $this->setProductPricesMapInitCallback(function (array $productPrices) {
            $productPricesMap = [];
            foreach ($productPrices as $productPrice) {
                $product = $productPrice->getProduct();
                $unit = $productPrice->getUnit();
                $price = $productPrice->getPrice();
                $productPricesMap[$product->getId()][$unit->getCode()][$price->getCurrency()][] =
                    $productPrice;
            }

            return $productPricesMap;
        });
    }

    #[\Override]
    public function offsetSet($key, $value): void
    {
        throw new \LogicException(__CLASS__ . ' is immutable.');
    }

    #[\Override]
    public function offsetUnset($key): void
    {
        throw new \LogicException(__CLASS__ . ' is immutable.');
    }

    #[\Override]
    public function append(mixed $value): void
    {
        throw new \LogicException(__CLASS__ . ' is immutable.');
    }

    #[\Override]
    public function exchangeArray(object|array $array): array
    {
        throw new \LogicException(__CLASS__ . ' is immutable.');
    }

    /**
     * @param \Closure $initCallback
     *  function (array $productPrices): array
     *
     * @return self
     */
    public function setProductPricesMapInitCallback(\Closure $initCallback): self
    {
        $this->productPricesMapInitCallback = $initCallback;
        $this->productPricesMap = null;

        return $this;
    }

    /**
     * @return array Array with arbitrary structure generated by $productPricesMapInitCallback from the list
     *  of ProductPriceInterface objects.
     *  Product prices map created by default init callback:
     *      [
     *          42 => [ // Product id
     *              'item' => [ // ProductUnit code
     *                  'USD' => [ // Currency
     *                      ProductPriceInterface,
     *                      // ...
     *                  ],
     *                  // ...
     *              ],
     *              // ...
     *          ],
     *          // ...
     *      ]
     */
    public function getProductPricesMap(): array
    {
        if ($this->productPricesMap === null) {
            $this->initProductPricesMap();
        }

        return $this->productPricesMap;
    }

    /**
     * @param string|int|bool|null ...$criteriaPath Array keys to get product prices by from the product prices map.
     *  Example:
     *      $productPricesCollection->getMatchingByCriteria(
     *          42, // Product ID
     *          'item', // Product Unit code
     *          'USD' // Currency
     *      )
     *
     * @return iterable<ProductPriceInterface>
     */
    public function getMatchingByCriteria(string|int|bool|null ...$criteriaPath): iterable
    {
        if ($this->productPricesMap === null) {
            $this->initProductPricesMap();
        }

        $productPrices = & $this->productPricesMap;
        foreach ($criteriaPath as $pathPart) {
            if (array_key_exists($pathPart, $productPrices)) {
                $productPrices = & $productPrices[$pathPart];
            } else {
                unset($productPrices);
                $productPrices = [];
                break;
            }
        }

        return new \RecursiveIteratorIterator(
            new \RecursiveArrayIterator($productPrices, \RecursiveArrayIterator::CHILD_ARRAYS_ONLY)
        );
    }

    protected function initProductPricesMap(): void
    {
        $this->productPricesMap = ($this->productPricesMapInitCallback)($this->getArrayCopy());
    }
}
